#!/usr/bin/env bash
set -euo pipefail
# normalized return codes
RC_OK=0
RC_SKIP=20
RC_FAIL=40

DIR="$(cd "$(dirname "$0")" && pwd)"
source "$DIR/bin/sg_runbook_lib.sh"
sg_begin "QE_VERIFY"

sg_init_logs

STEP="QE-VERIFY-040"
INP="${1:-$DIR/sample/llzo96_scf_300k.in}"

# 3) pw.x check helper (supports QE_PWX override)
check_pwx_or_skip() {
  local PWX="${QE_PWX:-}"
  if [[ -z "${PWX}" ]]; then PWX="$(command -v pw.x 2>/dev/null || true)"; fi
  if [[ -n "${PWX}" ]]; then sg_log "pwx=${PWX}"; fi
  if [[ -n "${PWX}" && ! -x "${PWX}" ]]; then
    sg_skip "QE_PWX is set but pw.x is not executable: ${PWX}" "$STEP" "E_QE_NOT_INSTALLED" "ls -la ${PWX}"
    exit $?
  fi

  if [[ -z "${PWX}" ]]; then
    sg_skip "pw.x not found; install QE first (or set PATH or QE_PWX). input check OK." "$STEP" "E_QE_NOT_INSTALLED" "command -v pw.x"
    exit $?
  fi
}

# Optional: check binary first (for onboarding tests)
if [[ "${QE_CHECK_BINARY_FIRST:-0}" == "1" ]]; then
  check_pwx_or_skip
fi

sg_log "input=$INP"

# 1) 入力の存在
if [ ! -f "$INP" ]; then
  sg_fail "QE input not found" "$STEP" "E_INPUT_NOT_FOUND" "ls -la $INP"
  exit $?
fi

# 2) pseudo_dir の存在チェック（よく落ちる）
PSEUDO_DIR="$(grep -E "^[[:space:]]*pseudo_dir" "$INP" | head -n 1 | sed -E "s/.*=['\"]?([^'\",[:space:]]+).*/\1/")"
PSEUDO_DIR="${PSEUDO_DIR:-pseudos}"

if [ ! -d "$PSEUDO_DIR" ]; then
  sg_fail "pseudo_dir missing (typical user error). Set pseudo_dir to actual UPF path." "$STEP" "E_PSEUDO_DIR_MISSING" "pseudo_dir=$PSEUDO_DIR"
  exit $?
fi

# 3) pw.x is required (default: after input checks)
check_pwx_or_skip

# v0.1: 実行は任意（SG_RUN=1のみ）
if [ "${SG_RUN:-0}" != "1" ]; then
  sg_pass "QE preflight OK. Set SG_RUN=1 to actually run: mpirun -np 1 pw.x -in ... (QE_NP/QE_TIMEOUT/QE_MPIRUN override)" "$STEP" "mpirun -np 1 pw.x -in $INP"
  exit 0
fi

sg_log "RUN: preparing mpirun pw.x (MPI build; direct launch may hang)"
MPIRUN="${QE_MPIRUN:-$(command -v mpirun 2>/dev/null || true)}"
if [[ -z "${MPIRUN}" ]]; then
  sg_skip "mpirun not found; MPI-enabled pw.x may hang if launched directly. Provide MPI or run with SG_RUN=0." "$STEP" "E_MPI_NOT_FOUND" "command -v mpirun"
  exit 0
fi

# If OPAL_PREFIX is unset, infer it from mpirun prefix so Open MPI can find help/runtime files.
if [[ -z "${OPAL_PREFIX:-}" ]]; then
  mp="$(readlink -f "${MPIRUN}" 2>/dev/null || echo "${MPIRUN}")"
  prefix="$(cd "$(dirname "$mp")/.." && pwd -P)"
  if [[ -r "${prefix}/share/openmpi/help-opal-runtime.txt" ]]; then
    export OPAL_PREFIX="$prefix"
  fi
fi

QE_NP="${QE_NP:-1}"
QE_TIMEOUT="${QE_TIMEOUT:-60s}"

sg_log "RUN: timeout ${QE_TIMEOUT} ${MPIRUN} -np ${QE_NP} ${PWX} -in $INP"
timeout "${QE_TIMEOUT}" "${MPIRUN}" -np "${QE_NP}" "${PWX}" -in "$INP" 2>&1 | tee -a "$SG_LOG_TXT"
sg_pass "pw.x finished (mpirun)." "$STEP" "mpirun -np ${QE_NP:-1} pw.x -in $INP"
