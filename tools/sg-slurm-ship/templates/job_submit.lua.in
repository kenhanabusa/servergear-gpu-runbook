-- Slurm JobSubmit plugin (generated by sg-apply-jobsubmit-mem)
-- Node template:
--   total_mem_mb=@TOTAL_MEM_MB@
--   total_cpus=@TOTAL_CPUS@
--   total_gpus=@TOTAL_GPUS@
--   gpu_margin=@GPU_MARGIN@
--   cpu_margin=@CPU_MARGIN@

local TOTAL_MEM_MB = @TOTAL_MEM_MB@
local TOTAL_CPUS = @TOTAL_CPUS@
local TOTAL_GPUS = @TOTAL_GPUS@
local GPU_MARGIN = @GPU_MARGIN@
local CPU_MARGIN = @CPU_MARGIN@

local MEM_PER_GPU_MB = math.floor((TOTAL_MEM_MB * (1.0 - GPU_MARGIN)) / TOTAL_GPUS)
local MEM_PER_CPU_MB = math.floor((TOTAL_MEM_MB * (1.0 - CPU_MARGIN)) / TOTAL_CPUS)

local NO_VAL_FLOOR = 900000000000
local LOG_NO_VAL_32 = 4294967294
local LOG_MAX_CPUS = math.max(TOTAL_CPUS * 4, 4096)
local LOG_NODE_MEM_MB = TOTAL_MEM_MB

local function lower_or_empty(s)
  if s == nil then return "" end
  return string.lower(tostring(s))
end

local function to_num(v)
  if v == nil then return nil end
  return tonumber(v)
end

local function is_unset_or_noval(v)
  local n = to_num(v)
  if n == nil then return true end
  if n <= 0 then return true end
  if n >= NO_VAL_FLOOR then return true end
  return false
end

local function has_mem_in_tres(job_desc)
  local fields = {
    job_desc.tres_per_job,
    job_desc.tres_per_node,
    job_desc.tres_per_task,
    job_desc.tres_per_socket,
  }
  for _, f in ipairs(fields) do
    local s = lower_or_empty(f)
    if string.find(s, "mem=") then
      return true
    end
  end
  return false
end

local function has_user_mem_request(job_desc)
  if has_mem_in_tres(job_desc) then
    return true
  end
  if not is_unset_or_noval(job_desc.min_mem_per_node) then
    return true
  end
  if not is_unset_or_noval(job_desc.min_mem_per_cpu) then
    return true
  end
  return false
end

local function gpus_from_field(field)
  if field == nil then return 0 end
  local s = lower_or_empty(field)
  local n = string.match(s, "gres/gpu[^=]*=([0-9]+)")
  if n ~= nil then return tonumber(n) end
  n = string.match(s, "gres/gpu[^,]*:([0-9]+)")
  if n ~= nil then return tonumber(n) end
  n = string.match(s, "gpu=([0-9]+)")
  if n ~= nil then return tonumber(n) end
  return 0
end

local function safe_positive_or_one(v)
  local n = to_num(v)
  if n == nil then return 1 end
  if n <= 0 then return 1 end
  if n >= NO_VAL_FLOOR then return 1 end
  return n
end

local function parse_gpu_count(job_desc)
  local fields = {
    job_desc.tres_per_job,
    job_desc.tres_per_node,
    job_desc.tres_per_task,
    job_desc.tres_per_socket,
  }
  for _, f in ipairs(fields) do
    local g = gpus_from_field(f)
    if g > 0 then
      if f == job_desc.tres_per_task then
        local nt = safe_positive_or_one(job_desc.num_tasks)
        return g * nt
      end
      return g
    end
  end

  local gres = lower_or_empty(job_desc.gres)
  if string.find(gres, "gpu") then
    local n = string.match(gres, ":([0-9]+)")
    if n ~= nil then return tonumber(n) end
    return 1
  end
  return 0
end

local function to_log_cpu_num(v)
  local n = to_num(v)
  if n == nil then return nil end
  if n <= 0 then return nil end
  if n >= LOG_NO_VAL_32 then return nil end
  n = math.floor(n)
  if n < 1 then return nil end
  if n > LOG_MAX_CPUS then return nil end
  return n
end

local function log_estimated_cpus(job_desc)
  local n = to_log_cpu_num(job_desc.num_cpus)
  if n ~= nil then return n end
  local cpt = to_log_cpu_num(job_desc.cpus_per_task) or 1
  local nt = to_log_cpu_num(job_desc.num_tasks) or 1
  local prod = cpt * nt
  if prod < 1 or prod > LOG_MAX_CPUS then
    return 1
  end
  return prod
end

local function log_estimated_mem_node(cpus)
  local est = cpus * MEM_PER_CPU_MB
  if est <= 0 then return nil end
  if est > (LOG_NODE_MEM_MB * 2) then
    return nil
  end
  return est
end

function slurm_job_submit(job_desc, part_list, submit_uid)
  local gpus = parse_gpu_count(job_desc)

  if has_user_mem_request(job_desc) then
    slurm.log_info("[job_submit.lua] explicit memory requested; keep user value")
    return slurm.SUCCESS
  end

  if gpus > 0 then
    local req_mem = gpus * MEM_PER_GPU_MB
    job_desc.min_mem_per_node = req_mem
    slurm.log_info(string.format(
      "[job_submit.lua] applied gpu_mem_per_node=%dM gpus=%d job=%s uid=%s",
      req_mem, gpus, tostring(job_desc.name), tostring(submit_uid)
    ))
  else
    job_desc.min_mem_per_cpu = MEM_PER_CPU_MB
    local log_cpus = log_estimated_cpus(job_desc)
    local log_est_mem = log_estimated_mem_node(log_cpus)
    local log_est_mem_s = "NA"
    if log_est_mem ~= nil then
      log_est_mem_s = tostring(log_est_mem) .. "M"
    end
    slurm.log_info(string.format(
      "[job_submit.lua] applied cpu_mem_per_cpu=%dM cpus=%d est_mem_node=%s job=%s uid=%s",
      MEM_PER_CPU_MB, log_cpus, log_est_mem_s, tostring(job_desc.name), tostring(submit_uid)
    ))
  end

  return slurm.SUCCESS
end

function slurm_job_modify(job_desc, job_rec, part_list, modify_uid)
  return slurm.SUCCESS
end
